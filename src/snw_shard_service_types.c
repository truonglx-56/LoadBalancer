/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "snw_shard_service_types.h"
#include <thrift/c_glib/thrift.h>

enum _snwInvalidOperationProperties
{
  PROP_SNW_INVALID_OPERATION_0,
  PROP_SNW_INVALID_OPERATION_WHAT_OP,
  PROP_SNW_INVALID_OPERATION_WHY
};

/* reads a invalid_operation object */
static gint32
snw_invalid_operation_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  snwInvalidOperation * this_object = SNW_INVALID_OPERATION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->whatOp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_whatOp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->why != NULL)
          {
            g_free(this_object->why);
            this_object->why = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->why, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_why = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
snw_invalid_operation_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  snwInvalidOperation * this_object = SNW_INVALID_OPERATION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "InvalidOperation", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "whatOp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->whatOp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "why", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->why, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
snw_invalid_operation_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  snwInvalidOperation *self = SNW_INVALID_OPERATION (object);

  switch (property_id)
  {
    case PROP_SNW_INVALID_OPERATION_WHAT_OP:
      self->whatOp = g_value_get_int (value);
      self->__isset_whatOp = TRUE;
      break;

    case PROP_SNW_INVALID_OPERATION_WHY:
      if (self->why != NULL)
        g_free (self->why);
      self->why = g_value_dup_string (value);
      self->__isset_why = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
snw_invalid_operation_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  snwInvalidOperation *self = SNW_INVALID_OPERATION (object);

  switch (property_id)
  {
    case PROP_SNW_INVALID_OPERATION_WHAT_OP:
      g_value_set_int (value, self->whatOp);
      break;

    case PROP_SNW_INVALID_OPERATION_WHY:
      g_value_set_string (value, self->why);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
snw_invalid_operation_instance_init (snwInvalidOperation * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->whatOp = 0;
  object->__isset_whatOp = FALSE;
  object->why = NULL;
  object->__isset_why = FALSE;
}

static void 
snw_invalid_operation_finalize (GObject *object)
{
  snwInvalidOperation *tobject = SNW_INVALID_OPERATION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->why != NULL)
  {
    g_free(tobject->why);
    tobject->why = NULL;
  }
}

static void
snw_invalid_operation_class_init (snwInvalidOperationClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = snw_invalid_operation_read;
  struct_class->write = snw_invalid_operation_write;

  gobject_class->finalize = snw_invalid_operation_finalize;
  gobject_class->get_property = snw_invalid_operation_get_property;
  gobject_class->set_property = snw_invalid_operation_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SNW_INVALID_OPERATION_WHAT_OP,
     g_param_spec_int ("whatOp",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SNW_INVALID_OPERATION_WHY,
     g_param_spec_string ("why",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
snw_invalid_operation_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (snwInvalidOperationClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) snw_invalid_operation_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (snwInvalidOperation),
      0, /* n_preallocs */
      (GInstanceInitFunc) snw_invalid_operation_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "snwInvalidOperationType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define SNW_INVALID_OPERATION_ERROR_DOMAIN "snw_invalid_operation_error_quark"
GQuark
snw_invalid_operation_error_quark (void)
{
  return g_quark_from_static_string (SNW_INVALID_OPERATION_ERROR_DOMAIN);
}

/* constants */

enum _snwShardServiceShardMapArgsProperties
{
  PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_0,
  PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_TYPE,
  PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_VERSION,
  PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_TOKEN
};

/* reads a shard_service_shard_map_args object */
static gint32
snw_shard_service_shard_map_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  snwShardServiceShardMapArgs * this_object = SNW_SHARD_SERVICE_SHARD_MAP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->type != NULL)
          {
            g_free(this_object->type);
            this_object->type = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->token != NULL)
          {
            g_free(this_object->token);
            this_object->token = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->token, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
snw_shard_service_shard_map_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  snwShardServiceShardMapArgs * this_object = SNW_SHARD_SERVICE_SHARD_MAP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ShardServiceShardMapArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_DOUBLE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->version, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->token, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
snw_shard_service_shard_map_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  snwShardServiceShardMapArgs *self = SNW_SHARD_SERVICE_SHARD_MAP_ARGS (object);

  switch (property_id)
  {
    case PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_TYPE:
      if (self->type != NULL)
        g_free (self->type);
      self->type = g_value_dup_string (value);
      self->__isset_type = TRUE;
      break;

    case PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_VERSION:
      self->version = g_value_get_double (value);
      self->__isset_version = TRUE;
      break;

    case PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_TOKEN:
      if (self->token != NULL)
        g_free (self->token);
      self->token = g_value_dup_string (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
snw_shard_service_shard_map_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  snwShardServiceShardMapArgs *self = SNW_SHARD_SERVICE_SHARD_MAP_ARGS (object);

  switch (property_id)
  {
    case PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_TYPE:
      g_value_set_string (value, self->type);
      break;

    case PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_VERSION:
      g_value_set_double (value, self->version);
      break;

    case PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_TOKEN:
      g_value_set_string (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
snw_shard_service_shard_map_args_instance_init (snwShardServiceShardMapArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->type = NULL;
  object->__isset_type = FALSE;
  object->version = 0;
  object->__isset_version = FALSE;
  object->token = NULL;
  object->__isset_token = FALSE;
}

static void 
snw_shard_service_shard_map_args_finalize (GObject *object)
{
  snwShardServiceShardMapArgs *tobject = SNW_SHARD_SERVICE_SHARD_MAP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->type != NULL)
  {
    g_free(tobject->type);
    tobject->type = NULL;
  }
  if (tobject->token != NULL)
  {
    g_free(tobject->token);
    tobject->token = NULL;
  }
}

static void
snw_shard_service_shard_map_args_class_init (snwShardServiceShardMapArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = snw_shard_service_shard_map_args_read;
  struct_class->write = snw_shard_service_shard_map_args_write;

  gobject_class->finalize = snw_shard_service_shard_map_args_finalize;
  gobject_class->get_property = snw_shard_service_shard_map_args_get_property;
  gobject_class->set_property = snw_shard_service_shard_map_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_TYPE,
     g_param_spec_string ("type",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_VERSION,
     g_param_spec_double ("version",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SNW_SHARD_SERVICE_SHARD_MAP_ARGS_TOKEN,
     g_param_spec_string ("token",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
snw_shard_service_shard_map_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (snwShardServiceShardMapArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) snw_shard_service_shard_map_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (snwShardServiceShardMapArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) snw_shard_service_shard_map_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "snwShardServiceShardMapArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _snwShardServiceShardMapResultProperties
{
  PROP_SNW_SHARD_SERVICE_SHARD_MAP_RESULT_0,
  PROP_SNW_SHARD_SERVICE_SHARD_MAP_RESULT_SUCCESS,
  PROP_SNW_SHARD_SERVICE_SHARD_MAP_RESULT_OUCH
};

/* reads a shard_service_shard_map_result object */
static gint32
snw_shard_service_shard_map_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  snwShardServiceShardMapResult * this_object = SNW_SHARD_SERVICE_SHARD_MAP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint64* key0 = g_new (gint64, 1);
              GHashTable * val1 = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
              if ((ret = thrift_protocol_read_i64 (protocol, &*key0, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType key_type;
                ThriftType value_type;

                /* read the map begin marker */
                if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through each of the map's fields */
                for (i = 0; i < size; i++)
                {
                  gchar * key2 = NULL;
                  gchar * val3 = NULL;
                  if (key2 != NULL)
                  {
                    g_free(key2);
                    key2 = NULL;
                  }

                  if ((ret = thrift_protocol_read_string (protocol, &key2, error)) < 0)
                    return -1;
                  xfer += ret;
                  if (val3 != NULL)
                  {
                    g_free(val3);
                    val3 = NULL;
                  }

                  if ((ret = thrift_protocol_read_string (protocol, &val3, error)) < 0)
                    return -1;
                  xfer += ret;
                  if (val1 && key2)
                    g_hash_table_insert ((GHashTable *)val1, (gpointer) key2, (gpointer) val3);
                }

                /* read the map end marker */
                if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if (this_object->success && key0)
                g_hash_table_insert ((GHashTable *)this_object->success, (gpointer) key0, (gpointer) val1);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ouch != NULL)
          {
            g_object_unref (this_object->ouch);
          }
          this_object->ouch = g_object_new (SNW_TYPE_INVALID_OPERATION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
          {
            g_object_unref (this_object->ouch);
            this_object->ouch = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ouch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
snw_shard_service_shard_map_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  snwShardServiceShardMapResult * this_object = SNW_SHARD_SERVICE_SHARD_MAP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ShardServiceShardMapResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_MAP, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      gint64* key4 = NULL;
      GHashTable * val5 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gint64** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_I64, T_MAP, this_object->success ? (gint32) g_hash_table_size ((GHashTable *) this_object->success) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->success)
        g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gint64*, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gint64*) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key4 = keys[i];
        val5 = (GHashTable *) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) key4);

        if ((ret = thrift_protocol_write_i64 (protocol, * key4, error)) < 0)
          return -1;
        xfer += ret;

        {
          gchar * key6 = NULL;
          gchar * val7 = NULL;
          GList *key_list = NULL, *iter = NULL;
          gchar ** keys;
          int i = 0, key_count;

          if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING,  val5 ? (gint32) g_hash_table_size ((GHashTable *)  val5) : 0, error)) < 0)
            return -1;
          xfer += ret;
          if ( val5)
            g_hash_table_foreach ((GHashTable *)  val5, thrift_hash_table_get_keys, &key_list);
          key_count = g_list_length (key_list);
          keys = g_newa (gchar *, key_count);
          for (iter = g_list_first (key_list); iter; iter = iter->next)
            keys[i++] = (gchar *) iter->data;
          g_list_free (key_list);

          for (i = 0; i < key_count; ++i)
          {
            key6 = keys[i];
            val7 = (gchar *) g_hash_table_lookup (((GHashTable *)  val5), (gpointer) key6);

            if ((ret = thrift_protocol_write_string (protocol,  key6, error)) < 0)
              return -1;
            xfer += ret;

            if ((ret = thrift_protocol_write_string (protocol,  val7, error)) < 0)
              return -1;
            xfer += ret;

          }
          if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
            return -1;
          xfer += ret;
        }
      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ouch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ouch", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
snw_shard_service_shard_map_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  snwShardServiceShardMapResult *self = SNW_SHARD_SERVICE_SHARD_MAP_RESULT (object);

  switch (property_id)
  {
    case PROP_SNW_SHARD_SERVICE_SHARD_MAP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SNW_SHARD_SERVICE_SHARD_MAP_RESULT_OUCH:
      if (self->ouch != NULL)
        g_object_unref (self->ouch);
      self->ouch = g_value_dup_object (value);
      self->__isset_ouch = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
snw_shard_service_shard_map_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  snwShardServiceShardMapResult *self = SNW_SHARD_SERVICE_SHARD_MAP_RESULT (object);

  switch (property_id)
  {
    case PROP_SNW_SHARD_SERVICE_SHARD_MAP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SNW_SHARD_SERVICE_SHARD_MAP_RESULT_OUCH:
      g_value_set_object (value, self->ouch);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
snw_shard_service_shard_map_result_instance_init (snwShardServiceShardMapResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_int64_hash, g_int64_equal, g_free, (GDestroyNotify) thrift_safe_hash_table_destroy);
  object->__isset_success = FALSE;
  object->ouch = NULL;
  object->__isset_ouch = FALSE;
}

static void 
snw_shard_service_shard_map_result_finalize (GObject *object)
{
  snwShardServiceShardMapResult *tobject = SNW_SHARD_SERVICE_SHARD_MAP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ouch != NULL)
  {
    g_object_unref(tobject->ouch);
    tobject->ouch = NULL;
  }
}

static void
snw_shard_service_shard_map_result_class_init (snwShardServiceShardMapResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = snw_shard_service_shard_map_result_read;
  struct_class->write = snw_shard_service_shard_map_result_write;

  gobject_class->finalize = snw_shard_service_shard_map_result_finalize;
  gobject_class->get_property = snw_shard_service_shard_map_result_get_property;
  gobject_class->set_property = snw_shard_service_shard_map_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SNW_SHARD_SERVICE_SHARD_MAP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SNW_SHARD_SERVICE_SHARD_MAP_RESULT_OUCH,
     g_param_spec_object ("ouch",
                         NULL,
                         NULL,
                         SNW_TYPE_INVALID_OPERATION,
                         G_PARAM_READWRITE));
}

GType
snw_shard_service_shard_map_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (snwShardServiceShardMapResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) snw_shard_service_shard_map_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (snwShardServiceShardMapResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) snw_shard_service_shard_map_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "snwShardServiceShardMapResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _snwShardServiceGetObjectIdArgsProperties
{
  PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_0,
  PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_MESSAGE,
  PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_VERSION,
  PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_TOKEN
};

/* reads a shard_service_get_object_id_args object */
static gint32
snw_shard_service_get_object_id_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  snwShardServiceGetObjectIdArgs * this_object = SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->token != NULL)
          {
            g_free(this_object->token);
            this_object->token = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->token, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
snw_shard_service_get_object_id_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  snwShardServiceGetObjectIdArgs * this_object = SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ShardServiceGetObjectIdArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_DOUBLE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->version, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->token, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
snw_shard_service_get_object_id_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  snwShardServiceGetObjectIdArgs *self = SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS (object);

  switch (property_id)
  {
    case PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    case PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_VERSION:
      self->version = g_value_get_double (value);
      self->__isset_version = TRUE;
      break;

    case PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_TOKEN:
      if (self->token != NULL)
        g_free (self->token);
      self->token = g_value_dup_string (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
snw_shard_service_get_object_id_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  snwShardServiceGetObjectIdArgs *self = SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS (object);

  switch (property_id)
  {
    case PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    case PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_VERSION:
      g_value_set_double (value, self->version);
      break;

    case PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_TOKEN:
      g_value_set_string (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
snw_shard_service_get_object_id_args_instance_init (snwShardServiceGetObjectIdArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->message = NULL;
  object->__isset_message = FALSE;
  object->version = 0;
  object->__isset_version = FALSE;
  object->token = NULL;
  object->__isset_token = FALSE;
}

static void 
snw_shard_service_get_object_id_args_finalize (GObject *object)
{
  snwShardServiceGetObjectIdArgs *tobject = SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
  if (tobject->token != NULL)
  {
    g_free(tobject->token);
    tobject->token = NULL;
  }
}

static void
snw_shard_service_get_object_id_args_class_init (snwShardServiceGetObjectIdArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = snw_shard_service_get_object_id_args_read;
  struct_class->write = snw_shard_service_get_object_id_args_write;

  gobject_class->finalize = snw_shard_service_get_object_id_args_finalize;
  gobject_class->get_property = snw_shard_service_get_object_id_args_get_property;
  gobject_class->set_property = snw_shard_service_get_object_id_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_VERSION,
     g_param_spec_double ("version",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_ARGS_TOKEN,
     g_param_spec_string ("token",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
snw_shard_service_get_object_id_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (snwShardServiceGetObjectIdArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) snw_shard_service_get_object_id_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (snwShardServiceGetObjectIdArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) snw_shard_service_get_object_id_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "snwShardServiceGetObjectIdArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _snwShardServiceGetObjectIdResultProperties
{
  PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT_0,
  PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT_SUCCESS,
  PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT_OUCH
};

/* reads a shard_service_get_object_id_result object */
static gint32
snw_shard_service_get_object_id_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  snwShardServiceGetObjectIdResult * this_object = SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ouch != NULL)
          {
            g_object_unref (this_object->ouch);
          }
          this_object->ouch = g_object_new (SNW_TYPE_INVALID_OPERATION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
          {
            g_object_unref (this_object->ouch);
            this_object->ouch = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ouch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
snw_shard_service_get_object_id_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  snwShardServiceGetObjectIdResult * this_object = SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ShardServiceGetObjectIdResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ouch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ouch", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ouch), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
snw_shard_service_get_object_id_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  snwShardServiceGetObjectIdResult *self = SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT (object);

  switch (property_id)
  {
    case PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT_OUCH:
      if (self->ouch != NULL)
        g_object_unref (self->ouch);
      self->ouch = g_value_dup_object (value);
      self->__isset_ouch = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
snw_shard_service_get_object_id_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  snwShardServiceGetObjectIdResult *self = SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT (object);

  switch (property_id)
  {
    case PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT_OUCH:
      g_value_set_object (value, self->ouch);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
snw_shard_service_get_object_id_result_instance_init (snwShardServiceGetObjectIdResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ouch = NULL;
  object->__isset_ouch = FALSE;
}

static void 
snw_shard_service_get_object_id_result_finalize (GObject *object)
{
  snwShardServiceGetObjectIdResult *tobject = SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ouch != NULL)
  {
    g_object_unref(tobject->ouch);
    tobject->ouch = NULL;
  }
}

static void
snw_shard_service_get_object_id_result_class_init (snwShardServiceGetObjectIdResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = snw_shard_service_get_object_id_result_read;
  struct_class->write = snw_shard_service_get_object_id_result_write;

  gobject_class->finalize = snw_shard_service_get_object_id_result_finalize;
  gobject_class->get_property = snw_shard_service_get_object_id_result_get_property;
  gobject_class->set_property = snw_shard_service_get_object_id_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SNW_SHARD_SERVICE_GET_OBJECT_ID_RESULT_OUCH,
     g_param_spec_object ("ouch",
                         NULL,
                         NULL,
                         SNW_TYPE_INVALID_OPERATION,
                         G_PARAM_READWRITE));
}

GType
snw_shard_service_get_object_id_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (snwShardServiceGetObjectIdResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) snw_shard_service_get_object_id_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (snwShardServiceGetObjectIdResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) snw_shard_service_get_object_id_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "snwShardServiceGetObjectIdResultType",
                                   &type_info, 0);
  }

  return type;
}

